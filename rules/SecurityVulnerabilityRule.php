<?php

namespace ReviewSystem\Rules;

use ReviewSystem\Engine\PerformanceOptimizedRule;
use ReviewSystem\Engine\RuleCategory;
use PhpParser\Node;
use PhpParser\Node\Expr\FuncCall;
use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Expr\Variable;
use PhpParser\Node\Scalar\String_;
use PhpParser\Node\Expr\ArrayDimFetch;
use PhpParser\Node\Expr\PropertyFetch;

/**
 * Advanced Security Vulnerability Detection Rule
 *
 * Detects various security vulnerabilities including:
 * - SQL Injection
 * - XSS (Cross-Site Scripting)
 * - CSRF vulnerabilities
 * - File inclusion vulnerabilities
 * - Command injection
 * - Authentication bypass
 * - Sensitive data exposure
 */
class SecurityVulnerabilityRule extends PerformanceOptimizedRule
{
    private array $dangerousFunctions = [
        'eval', 'exec', 'system', 'shell_exec', 'passthru',
        'include', 'include_once', 'require', 'require_once',
        'file_get_contents', 'file_put_contents', 'unlink',
        'rmdir', 'mkdir', 'chmod', 'chown', 'chgrp'
    ];

    private array $sqlKeywords = [
        'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE',
        'ALTER', 'TRUNCATE', 'EXEC', 'EXECUTE', 'UNION'
    ];

    private array $xssPatterns = [
        '<script', 'javascript:', 'onload=', 'onerror=', 'onclick=',
        'onmouseover=', 'onfocus=', 'onblur=', 'onchange='
    ];

    private array $sensitiveDataPatterns = [
        'password', 'secret', 'key', 'token', 'api_key',
        'private_key', 'secret_key', 'access_token'
    ];

    public function getCategory(): string
    {
        return RuleCategory::SECURITY;
    }

    public function getName(): string
    {
        return 'Security Vulnerability Detection';
    }

    public function getDescription(): string
    {
        return 'Detects various security vulnerabilities including SQL injection, XSS, CSRF, file inclusion, ' .
            'command injection, authentication bypass, and sensitive data exposure.';
    }

    public function getSeverity(): string
    {
        return 'error';
    }

    public function getTags(): array
    {
        return ['security', 'vulnerability', 'sql-injection', 'xss', 'csrf', 'authentication', 'data-exposure'];
    }

    public function isEnabledByDefault(): bool
    {
        return true;
    }

    public function getConfigurationOptions(): array
    {
        return [
            'check_sql_injection' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for SQL injection vulnerabilities'
            ],
            'check_xss' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for XSS vulnerabilities'
            ],
            'check_csrf' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for CSRF vulnerabilities'
            ],
            'check_file_inclusion' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for file inclusion vulnerabilities'
            ],
            'check_command_injection' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for command injection vulnerabilities'
            ],
            'check_authentication_bypass' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for authentication bypass vulnerabilities'
            ],
            'check_sensitive_data' => [
                'type' => 'boolean',
                'default' => true,
                'description' => 'Check for sensitive data exposure'
            ],
            'dangerous_functions' => [
                'type' => 'array',
                'default' => $this->dangerousFunctions,
                'description' => 'List of dangerous functions to check'
            ],
            'sensitive_patterns' => [
                'type' => 'array',
                'default' => $this->sensitiveDataPatterns,
                'description' => 'Patterns for sensitive data detection'
            ]
        ];
    }

    protected function performChecks(array $ast, string $filePath): array
    {
        $violations = [];

        // Check for SQL injection vulnerabilities
        if ($this->getConfig('check_sql_injection', true)) {
            $violations = array_merge($violations, $this->checkSqlInjection($ast, $filePath));
        }

        // Check for XSS vulnerabilities
        if ($this->getConfig('check_xss', true)) {
            $violations = array_merge($violations, $this->checkXSS($ast, $filePath));
        }

        // Check for CSRF vulnerabilities
        if ($this->getConfig('check_csrf', true)) {
            $violations = array_merge($violations, $this->checkCSRF($ast, $filePath));
        }

        // Check for file inclusion vulnerabilities
        if ($this->getConfig('check_file_inclusion', true)) {
            $violations = array_merge($violations, $this->checkFileInclusion($ast, $filePath));
        }

        // Check for command injection vulnerabilities
        if ($this->getConfig('check_command_injection', true)) {
            $violations = array_merge($violations, $this->checkCommandInjection($ast, $filePath));
        }

        // Check for authentication bypass vulnerabilities
        if ($this->getConfig('check_authentication_bypass', true)) {
            $violations = array_merge($violations, $this->checkAuthenticationBypass($ast, $filePath));
        }

        // Check for sensitive data exposure
        if ($this->getConfig('check_sensitive_data', true)) {
            $violations = array_merge($violations, $this->checkSensitiveDataExposure($ast, $filePath));
        }

        return $violations;
    }

    private function checkSqlInjection(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            if ($node instanceof FuncCall && $node->name instanceof Node\Name) {
                $functionName = $node->name->toString();

                // Check for raw SQL queries
                if (
                    in_array(strtolower($functionName), [
                    'db::raw', 'db::select', 'db::insert', 'db::update', 'db::delete'
                    ])
                ) {
                    foreach ($node->args as $arg) {
                        if ($this->containsUserInput($arg->value)) {
                            $violations[] = [
                                'line' => $node->getLine(),
                                'message' => 'Potential SQL injection vulnerability: Raw SQL query with user input',
                                'category' => 'sql-injection',
                                'severity' => 'error',
                                'suggestion' => 'Use parameterized queries or Eloquent ORM methods',
                                'code' => $this->formatBadCode($node)
                            ];
                        }
                    }
                }
            }

            // Check for SQL keywords in string literals with user input
            if ($node instanceof String_) {
                $value = $node->value;
                foreach ($this->sqlKeywords as $keyword) {
                    if (stripos($value, $keyword) !== false && $this->containsUserInput($node)) {
                        $violations[] = [
                            'line' => $node->getLine(),
                            'message' => "Potential SQL injection: SQL keyword '{$keyword}' found with user input",
                            'category' => 'sql-injection',
                            'severity' => 'error',
                            'suggestion' => 'Use parameterized queries instead of string concatenation',
                            'code' => $this->formatBadCode($node)
                        ];
                    }
                }
            }
        }

        return $violations;
    }

    private function checkXSS(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            if ($node instanceof String_) {
                $value = $node->value;
                foreach ($this->xssPatterns as $pattern) {
                    if (stripos($value, $pattern) !== false && $this->containsUserInput($node)) {
                        $violations[] = [
                            'line' => $node->getLine(),
                            'message' => "Potential XSS vulnerability: Found '{$pattern}' with user input",
                            'category' => 'xss',
                            'severity' => 'error',
                            'suggestion' => 'Use htmlspecialchars() or Blade escaping to prevent XSS',
                            'code' => $this->formatBadCode($node)
                        ];
                    }
                }
            }

            // Check for echo/print statements with user input
            if ($node instanceof FuncCall && in_array($node->name->toString(), ['echo', 'print'])) {
                foreach ($node->args as $arg) {
                    if ($this->containsUserInput($arg->value)) {
                        $violations[] = [
                            'line' => $node->getLine(),
                            'message' => 'Potential XSS vulnerability: Direct output of user input',
                            'category' => 'xss',
                            'severity' => 'error',
                            'suggestion' => 'Use htmlspecialchars() or Blade escaping before output',
                            'code' => $this->formatBadCode($node)
                        ];
                    }
                }
            }
        }

        return $violations;
    }

    private function checkCSRF(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            // Check for forms without CSRF tokens
            if ($node instanceof FuncCall && $node->name->toString() === 'form') {
                $hasCsrfToken = false;
                foreach ($node->args as $arg) {
                    if ($arg->value instanceof String_ && strpos($arg->value->value, '@csrf') !== false) {
                        $hasCsrfToken = true;
                        break;
                    }
                }

                if (!$hasCsrfToken) {
                    $violations[] = [
                        'line' => $node->getLine(),
                        'message' => 'CSRF vulnerability: Form without CSRF token protection',
                        'category' => 'csrf',
                        'severity' => 'error',
                        'suggestion' => 'Add @csrf directive to Blade forms or use csrf_field() helper',
                        'code' => $this->formatBadCode($node)
                    ];
                }
            }
        }

        return $violations;
    }

    private function checkFileInclusion(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            if ($node instanceof FuncCall && $node->name instanceof Node\Name) {
                $functionName = $node->name->toString();

                if (in_array($functionName, ['include', 'include_once', 'require', 'require_once'])) {
                    foreach ($node->args as $arg) {
                        if ($this->containsUserInput($arg->value)) {
                            $violations[] = [
                                'line' => $node->getLine(),
                                'message' => 'File inclusion vulnerability: Dynamic file inclusion with user input',
                                'category' => 'file-inclusion',
                                'severity' => 'error',
                                'suggestion' => 'Validate and sanitize file paths, use whitelist approach',
                                'code' => $this->formatBadCode($node)
                            ];
                        }
                    }
                }
            }
        }

        return $violations;
    }

    private function checkCommandInjection(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            if ($node instanceof FuncCall && $node->name instanceof Node\Name) {
                $functionName = $node->name->toString();

                if (in_array($functionName, $this->dangerousFunctions)) {
                    foreach ($node->args as $arg) {
                        if ($this->containsUserInput($arg->value)) {
                            $violations[] = [
                                'line' => $node->getLine(),
                                'message' => "Command injection vulnerability: Dangerous function '{$functionName}' " .
                                    'with user input',
                                'category' => 'command-injection',
                                'severity' => 'error',
                                'suggestion' => 'Avoid using dangerous functions with user input, ' .
                                    'use safer alternatives',
                                'code' => $this->formatBadCode($node)
                            ];
                        }
                    }
                }
            }
        }

        return $violations;
    }

    private function checkAuthenticationBypass(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            // Check for hardcoded credentials
            if ($node instanceof String_) {
                $value = $node->value;
                if (preg_match('/^(admin|root|user|password|123456|admin123)$/i', $value)) {
                    $violations[] = [
                        'line' => $node->getLine(),
                        'message' => 'Authentication bypass risk: Hardcoded credentials found',
                        'category' => 'authentication-bypass',
                        'severity' => 'warning',
                        'suggestion' => 'Use environment variables for credentials, never hardcode them',
                        'code' => $this->formatBadCode($node)
                    ];
                }
            }

            // Check for missing authentication checks
            if ($node instanceof MethodCall && $node->name->toString() === 'middleware') {
                $hasAuthMiddleware = false;
                foreach ($node->args as $arg) {
                    if ($arg->value instanceof String_ && in_array($arg->value->value, ['auth', 'auth:sanctum'])) {
                        $hasAuthMiddleware = true;
                        break;
                    }
                }

                if (!$hasAuthMiddleware) {
                    $violations[] = [
                        'line' => $node->getLine(),
                        'message' => 'Authentication bypass risk: Route without authentication middleware',
                        'category' => 'authentication-bypass',
                        'severity' => 'warning',
                        'suggestion' => 'Add authentication middleware to protect sensitive routes',
                        'code' => $this->formatBadCode($node)
                    ];
                }
            }
        }

        return $violations;
    }

    private function checkSensitiveDataExposure(array $ast, string $filePath): array
    {
        $violations = [];

        foreach ($ast as $node) {
            if ($node instanceof String_) {
                $value = $node->value;
                foreach ($this->sensitiveDataPatterns as $pattern) {
                    if (stripos($value, $pattern) !== false) {
                        $violations[] = [
                            'line' => $node->getLine(),
                            'message' => "Sensitive data exposure: Found '{$pattern}' in code",
                            'category' => 'data-exposure',
                            'severity' => 'warning',
                            'suggestion' => 'Use environment variables for sensitive data, never expose in code',
                            'code' => $this->formatBadCode($node)
                        ];
                    }
                }
            }

            // Check for sensitive data in variable names
            if ($node instanceof Variable) {
                $varName = is_string($node->name) ? $node->name : '';

                foreach ($this->sensitiveDataPatterns as $pattern) {
                    if (stripos($varName, $pattern) !== false) {
                        $violations[] = [
                            'line' => $node->getLine(),
                            'message' => "Sensitive data exposure: Variable name contains '{$pattern}'",
                            'category' => 'data-exposure',
                            'severity' => 'warning',
                            'suggestion' => 'Use generic variable names to avoid exposing sensitive data',
                            'code' => $this->formatBadCode($node)
                        ];
                    }
                }
            }
        }

        return $violations;
    }

    private function containsUserInput(Node $node): bool
    {
        // Check if node contains user input (simplified detection)
        if ($node instanceof Variable) {
            $varName = is_string($node->name) ? $node->name : '';
            return in_array($varName, ['$_GET', '$_POST', '$_REQUEST', '$_COOKIE', '$_FILES', 'request', 'input']);
        }

        if ($node instanceof ArrayDimFetch) {
            return $this->containsUserInput($node->var);
        }

        if ($node instanceof PropertyFetch) {
            return $this->containsUserInput($node->var);
        }

        if ($node instanceof FuncCall) {
            $functionName = $node->name instanceof Node\Name ? $node->name->toString() : '';
            return in_array($functionName, ['request', 'input', 'old', 'session']);
        }

        return false;
    }

    private function getConfig(string $key, $default = null)
    {
        $options = $this->getConfigurationOptions();
        return $options[$key]['default'] ?? $default;
    }

    private function formatBadCode(Node $node): string
    {
        if ($node instanceof FuncCall && $node->name instanceof Node\Name) {
            $functionName = $node->name->toString();
            return "{$functionName}()";
        }

        if ($node instanceof String_) {
            return "'{$node->value}'";
        }

        if ($node instanceof Variable) {
            $varName = is_string($node->name) ? $node->name : '';
            return "\${$varName}";
        }

        if ($node instanceof MethodCall) {
            $method = $node->name->name ?? 'method';
            return "->{$method}()";
        }

        return 'Security vulnerability detected';
    }
}
